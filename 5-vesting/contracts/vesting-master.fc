#include "imports/stdlib.fc";
#include "imports/utils.fc";

;; Common Operations
const int op::provide_wallet_address = 0x2c76b973;
const int op::take_wallet_address = 0xd1735400;
const int op::create_vesting_wallet = 0x5fe9b8cd;
const int op::collect_royalty = 0xd374ab1c;

;; Vesting Logger Operations
const int op::register_wallet = 0xd1d1d1d1;
const int op::set_logger_address = 0x4567;

;; only owner operations
const int op::update_vesting_wallet_code = 0x1234;
const int op::change_owner = 0x2345;
const int op::withdraw_tons = 0x3456;

;; Error Codes
const int error::invalid_op = 0xffff;
const int error::access_denied = 0xffa0;
const int error::insufficient_fee = 0xffa2;
const int error::insufficient_balance = 0xffa3;

;; Send Modes
const int send_mode::regular = 0;
const int send_mode::pay_gas_separately = 1;
const int send_mode::carry_remaining_gas = 64;

;; Royalty Constants
const int royalty::fee = 10000000; ;; 0.01 TON per vesting wallet creation

;; Minimum TON balance required for storage
const int min_tons_for_storage = 10000000;

;; Address size
const int ADDRESS_SIZE = 267; ;; 256 + 8

;; Global variables for storage
global slice storage::owner_address;
global cell storage::vesting_wallet_code; 
global slice storage::logger_address;
global int storage::total_wallets_created;
global int storage::total_royalty_collected;

;; Helper to compare two addresses
int equal_slices(slice a, slice b) {
    return a.slice_hash() == b.slice_hash();
}

;; Load data into global variables
() load_data() impure inline {
    var ds = get_data().begin_parse();
    if (ds.slice_bits() == 0) {
        storage::owner_address = null();
        storage::vesting_wallet_code = null();
        storage::logger_address = null();
        storage::total_wallets_created = 0;
        storage::total_royalty_collected = 0;
        return ();
    }
    
    storage::owner_address = ds~load_msg_addr();
    
    if (ds.slice_refs() == 0) {
        storage::vesting_wallet_code = null();
        storage::logger_address = null();
        storage::total_wallets_created = 0;
        storage::total_royalty_collected = 0;
        return ();
    }
    
    storage::vesting_wallet_code = ds~load_ref();
    
    if (ds.slice_bits() < 267) {
        storage::logger_address = null();
        storage::total_wallets_created = 0;
        storage::total_royalty_collected = 0;
        return ();
    }
    
    storage::logger_address = ds~load_msg_addr();
    
    if (ds.slice_bits() < 64) {
        storage::total_wallets_created = 0;
        storage::total_royalty_collected = 0;
        return ();
    }
    
    storage::total_wallets_created = ds~load_uint(64);
    
    if (ds.slice_bits() < 124) {
        storage::total_royalty_collected = 0;
        return ();
    }
    
    storage::total_royalty_collected = ds~load_coins();
}

;; Save data from global variables
() save_data() impure inline {
    set_data(begin_cell()
        .store_slice(storage::owner_address)
        .store_ref(storage::vesting_wallet_code)
        .store_slice(storage::logger_address)
        .store_uint(storage::total_wallets_created, 64)
        .store_coins(storage::total_royalty_collected)
        .end_cell());
}

;; Calculate vesting wallet address from owner, params, and state init
slice calculate_vesting_wallet_address(cell state_init) inline {
    return begin_cell()
        .store_uint(4, 3)
        .store_int(0, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

;; Updated with new parameters
cell create_vesting_wallet_state_init(slice owner_address, slice recipient_address, slice jetton_master_address, 
    int vesting_total_amount, int vesting_params, int is_auto_claim, 
    int cancel_permission, int change_recipient_permission, cell wallet_code) inline {

    cell data = begin_cell()
        .store_slice(owner_address) 
        .store_slice(recipient_address)
        .store_slice(jetton_master_address)
        .store_coins(vesting_total_amount)
        .store_uint(vesting_params, 128)
        .store_uint(is_auto_claim, 1)
        .store_uint(cancel_permission, 3)
        .store_uint(change_recipient_permission, 3)
        .store_coins(0) ;; Initial claimed amount
        .end_cell();
    
    return begin_cell()
        .store_uint(0, 2)
        .store_dict(wallet_code)
        .store_dict(data)
        .store_uint(0, 1)
        .end_cell();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return (); ;; Accept TON transfers
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return (); ;; Ignore bounced messages
    }
    
    slice sender_addr = cs~load_msg_addr();
    cs~load_coins(); ;; Skip value
    cs~skip_bits(1); ;; Skip extracurrency collection
    cs~load_coins(); ;; Skip ihr_fee
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Load global variables
    load_data();
    
    ;; Handle create_vesting_wallet operation with new parameters
    if (op == op::create_vesting_wallet) {
        throw_unless(error::insufficient_fee, msg_value >= royalty::fee);
    
        slice vesting_owner = in_msg_body~load_msg_addr();
        slice vesting_recipient = in_msg_body~load_msg_addr();
        slice jetton_master = in_msg_body~load_msg_addr();
        int vesting_total_amount = in_msg_body~load_coins();
    
        ;; Load reference cell with remaining parameters
        slice ref_data = in_msg_body~load_ref().begin_parse();
    
        int vesting_start_time = ref_data~load_uint(32);
        int vesting_total_duration = ref_data~load_uint(32);
        int unlock_period = ref_data~load_uint(32);
        int cliff_duration = ref_data~load_uint(32);
        int is_auto_claim = ref_data~load_uint(1);
        int cancel_contract_permission = ref_data~load_uint(3);
        int change_recipient_permission = ref_data~load_uint(3);
        int forward_remaining_balance = ref_data~load_coins();

        throw_unless(39, vesting_start_time > 0);
        throw_unless(40, vesting_total_duration > 0);
        throw_unless(41, unlock_period > 0);
        throw_unless(42, (is_auto_claim == 0) | (is_auto_claim == 1));
        throw_unless(43, (1 <= cancel_contract_permission) & (cancel_contract_permission <= 4));
        throw_unless(44, (1 <= change_recipient_permission) & (change_recipient_permission <= 4));
    
        ;; Pack vesting parameters for compact storage
        int packed_params = (vesting_start_time << 96) | 
        (vesting_total_duration << 64) | 
        (unlock_period << 32) | cliff_duration;
    
        ;; Create state init for the vesting wallet
        cell state_init = create_vesting_wallet_state_init(
            vesting_owner, 
            vesting_recipient, 
            jetton_master, 
            vesting_total_amount,
            packed_params,
            is_auto_claim,
            cancel_contract_permission,
            change_recipient_permission,
            storage::vesting_wallet_code
        );
        
        ;; Calculate the address of the new vesting wallet
        slice vesting_wallet_address = calculate_vesting_wallet_address(state_init);
        
        ;; Create deploy message with state init
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(vesting_wallet_address)
            .store_coins(forward_remaining_balance) ;; Forward all remaining balance
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(begin_cell().end_cell());
        
        send_raw_message(msg.end_cell(), send_mode::carry_remaining_gas);
        
        ;; Send royalty fee to owner
        var royalty_msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(storage::owner_address)
            .store_coins(royalty::fee)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::collect_royalty, 32)
            .store_uint(query_id, 64)
            .store_uint(storage::total_wallets_created + 1, 64);
        
        send_raw_message(royalty_msg.end_cell(), send_mode::pay_gas_separately);
        
        ;; Send log message to logger
        if ((storage::logger_address.preload_uint(2) != 0) & (~ equal_slices(storage::logger_address, null()))) {
            var log_msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(storage::logger_address)
            .store_coins(50000000) ;; 0.05 TON for processing
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::register_wallet, 32)
            .store_uint(query_id, 64)
            .store_slice(vesting_wallet_address)
            .store_slice(jetton_master)
            .store_slice(vesting_owner)
            .store_slice(vesting_recipient)
            .store_uint(is_auto_claim, 32);
            
            send_raw_message(log_msg.end_cell(), send_mode::pay_gas_separately);
        }

        ;; Update state with new royalty collected and wallets created
        storage::total_wallets_created += 1;
        storage::total_royalty_collected += royalty::fee;
        save_data();
        
        ;; Send wallet address back to sender
        var addr_msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_addr)
            .store_coins(10000000) ;; Forward all remaining balance 0.01 TON
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::take_wallet_address, 32)
            .store_uint(query_id, 64)
            .store_slice(vesting_wallet_address);
        
        send_raw_message(addr_msg.end_cell(), send_mode::pay_gas_separately);
        
        return ();
    }

    if (op == op::set_logger_address) {
        throw_unless(error::access_denied, equal_slices(sender_addr, storage::owner_address));
        slice new_logger = in_msg_body~load_msg_addr();
    
        storage::logger_address = new_logger;
        save_data();
        return ();
    }
    
    ;; Handle provide_wallet_address operation with new parameters
    if (op == op::provide_wallet_address) {
        slice owner_addr = in_msg_body~load_msg_addr();
        slice recipient_addr = in_msg_body~load_msg_addr();
        slice jetton_master = in_msg_body~load_msg_addr();
        int vesting_total_amount = in_msg_body~load_coins();
        int include_state_init = in_msg_body~load_uint(1);
    
        ;; Load vesting parameters
        int vesting_start_time = in_msg_body~load_uint(32);
        int vesting_total_duration = in_msg_body~load_uint(32);
        int unlock_period = in_msg_body~load_uint(32);
        int cliff_duration = in_msg_body~load_uint(32);
        int is_auto_claim = in_msg_body~load_uint(1);
        int cancel_contract_permission = in_msg_body~load_uint(3);
        int change_recipient_permission = in_msg_body~load_uint(3);
    
        ;; Tip kontrolleri
        throw_unless(39, vesting_start_time > 0);
        throw_unless(40, vesting_total_duration > 0);
        throw_unless(41, unlock_period > 0);
        throw_unless(42, (is_auto_claim == 0) | (is_auto_claim == 1));
        throw_unless(43, (1 <= cancel_contract_permission) & (cancel_contract_permission <= 4));
        throw_unless(44, (1 <= change_recipient_permission) & (change_recipient_permission <= 4));
    
        ;; Pack vesting parameters for compact storage
        int packed_params = (vesting_start_time << 96) | 
        (vesting_total_duration << 64) | 
        (unlock_period << 32) | cliff_duration;
    
        ;; Create state init for the vesting wallet
        cell state_init = create_vesting_wallet_state_init(
            owner_addr, 
            recipient_addr, 
            jetton_master, 
            vesting_total_amount,
            packed_params,
            is_auto_claim,
            cancel_contract_permission,
            change_recipient_permission,
            storage::vesting_wallet_code
        );
        
        ;; Calculate the address of the vesting wallet
        slice vesting_wallet_address = calculate_vesting_wallet_address(state_init);
        
        ;; Create response message
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_addr)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::take_wallet_address, 32)
            .store_uint(query_id, 64)
            .store_slice(vesting_wallet_address);
        
        ;; Include state init if requested
        if (include_state_init) {
            msg = msg.store_uint(1, 1).store_ref(state_init);
        } else {
            msg = msg.store_uint(0, 1);
        }
        
        send_raw_message(msg.end_cell(), send_mode::pay_gas_separately);
        return ();
    }
    
    ;; Handle owner-specific operations
    if (equal_slices(sender_addr, storage::owner_address)) {
        ;; Update vesting wallet code (owner only)
        if (op == op::update_vesting_wallet_code) {
            cell new_code = in_msg_body~load_ref();
            storage::vesting_wallet_code = new_code;
            save_data();
            return ();
        }
        
        ;; Change owner (owner only)
        if (op == op::change_owner) { ;; change_owner op
            slice new_owner = in_msg_body~load_msg_addr();
            storage::owner_address = new_owner;
            save_data();
            return ();
        }
        
        ;; Withdraw excess TON (owner only)
        if (op == op::withdraw_tons) { ;; withdraw_tons op
            int withdraw_amount = in_msg_body~load_coins();
            var [balance, _] = get_balance();
            throw_unless(error::insufficient_balance, balance >= withdraw_amount);
            int return_value = min(withdraw_amount, balance - min_tons_for_storage);

            var msg = begin_cell()
                .store_uint(0x10, 6)
                .store_slice(storage::owner_address)
                .store_coins(return_value)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
                
            send_raw_message(msg.end_cell(), send_mode::pay_gas_separately);
            return ();
        }
    }
    
    ;; Unknown operation
    throw(error::invalid_op);
}

;; Get methods

;; Returns royalty fee
int get_royalty_fee() method_id {
    return royalty::fee;
}

;; Returns contract owner
slice get_owner() method_id {
    load_data();
    return storage::owner_address;
}

;; Returns vesting wallet code
cell get_wallet_code() method_id {
    load_data();
    return storage::vesting_wallet_code;
}

;; Returns stats
(int, int) get_vesting_stats() method_id {
    load_data();
    return (storage::total_wallets_created, storage::total_royalty_collected);
}

;; Returns vesting wallet address for a given owner and parameters - updated with new parameters
slice get_wallet_address(slice owner_address, slice recipient_address, slice jetton_master_address, 
    int vesting_total_amount, int vesting_start_time, int vesting_total_duration, 
    int unlock_period, int cliff_duration, int is_auto_claim, 
    int cancel_contract_permission, int change_recipient_permission) method_id {
    
    load_data();
    
    ;; Check if wallet code is available
    if (cell_null?(storage::vesting_wallet_code)) {
        return null_addr();
    }
    
    ;; Pack vesting parameters for compact storage
    int packed_params = (vesting_start_time << 96) | 
    (vesting_total_duration << 64) | 
    (unlock_period << 32) | 
                       cliff_duration;
    
    ;; Create state init for the vesting wallet
    cell state_init = create_vesting_wallet_state_init(
        owner_address,
        recipient_address,
        jetton_master_address,
        vesting_total_amount,
        packed_params,
        is_auto_claim,
        cancel_contract_permission,
        change_recipient_permission,
        storage::vesting_wallet_code
    );
    
    ;; Calculate the address of the vesting wallet
    return calculate_vesting_wallet_address(state_init);
}

slice get_logger_address() method_id {
    load_data();
    return storage::logger_address;
}