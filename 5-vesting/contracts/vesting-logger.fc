#include "imports/stdlib.fc";
#include "imports/utils.fc";

;; Operations
const int op::register_wallet = 0xd1d1d1d1;
const int op::update_recipient = 0xd2d2d2d2;
const int op::log_claim = 0xd3d3d3d3;
const int op::log_cancel = 0xd4d4d4d4;

;; Error codes
const int error::access_denied = 0x1001;

;; Define global variables for storage
global slice storage::owner;
global cell storage::token_wallets;
global cell storage::owner_wallets;
global cell storage::receiver_wallets;
global cell storage::auto_claim_wallets;
global int storage::init?;

;; Helper to compare two addresses
int equal_slices(slice a, slice b) {
    return a.slice_hash() == b.slice_hash();
}

;; Load data into global variables
() load_data() impure inline {
    slice ds = get_data().begin_parse();
    
    ;; Check if data cell is empty
    if (ds.slice_bits() == 0) {
        storage::owner = null();
        storage::token_wallets = new_dict();
        storage::owner_wallets = new_dict();
        storage::receiver_wallets = new_dict();
        storage::auto_claim_wallets = new_dict();
        storage::init? = false;
        return ();
    }
    
    ;; Load owner address
    storage::owner = ds~load_msg_addr();
    storage::init? = true;
    
    ;; Check if we have more data
    if (ds.slice_refs() < 1) {
        storage::token_wallets = new_dict();
        storage::owner_wallets = new_dict();
        storage::receiver_wallets = new_dict();
        storage::auto_claim_wallets = new_dict();
        return ();
    }
    
    ;; Load token wallets dictionary
    storage::token_wallets = ds~load_dict();
    
    ;; Check if we have more refs
    if (ds.slice_refs() < 1) {
        storage::owner_wallets = new_dict();
        storage::receiver_wallets = new_dict();
        storage::auto_claim_wallets = new_dict();
        return ();
    }
    
    ;; Load owner wallets dictionary
    storage::owner_wallets = ds~load_dict();
    
    ;; Check if we have more refs
    if (ds.slice_refs() < 1) {
        storage::receiver_wallets = new_dict();
        storage::auto_claim_wallets = new_dict();
        return ();
    }
    
    ;; Load receiver wallets dictionary
    storage::receiver_wallets = ds~load_dict();
    
    ;; Check if we have the final ref
    if (ds.slice_refs() < 1) {
        storage::auto_claim_wallets = new_dict();
        return ();
    }
    
    ;; Load auto claim wallets dictionary
    storage::auto_claim_wallets = ds~load_dict();
}

;; Save data from global variables
() save_data() impure inline {
    set_data(begin_cell()
        .store_slice(storage::owner)
        .store_dict(storage::token_wallets)
        .store_dict(storage::owner_wallets)
        .store_dict(storage::receiver_wallets)
        .store_dict(storage::auto_claim_wallets)
        .end_cell());
}

;; Add wallet to a specific index
cell add_to_index(cell index_dict, slice key_address, slice wallet_address) inline {
    (int key_wc, int key_hash) = parse_std_addr(key_address);
    
    ;; Get or create inner dictionary
    (slice value_slice, int found) = index_dict.udict_get?(267, key_hash);
    cell inner_dict = found ? value_slice.preload_ref() : new_dict();
    
    ;; Add wallet to inner dictionary
    (int wallet_wc, int wallet_hash) = parse_std_addr(wallet_address);
    inner_dict~udict_set_builder(267, wallet_hash, begin_cell().store_int(-1, 1));
    
    ;; Update outer dictionary
    return index_dict.udict_set_ref(267, key_hash, inner_dict);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return (); ;; Accept TON transfers
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return (); ;; Ignore bounced messages
    }
    
    slice sender_addr = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Load data into global variables
    load_data();
    
    if (storage::owner.preload_uint(2) == 0) {
        storage::owner = sender_addr;
        storage::init? = true;
    }
    
    throw_unless(error::access_denied, equal_slices(sender_addr, storage::owner));
    
    if (op == op::register_wallet) {
        ;; Register a new vesting wallet
        slice wallet_address = in_msg_body~load_msg_addr();
        slice token_address = in_msg_body~load_msg_addr();
        slice wallet_owner_address = in_msg_body~load_msg_addr();
        slice receiver_address = in_msg_body~load_msg_addr();
        int is_auto_claim = in_msg_body~load_uint(32);
        
        ;; Update token -> wallets mapping
        storage::token_wallets = add_to_index(storage::token_wallets, token_address, wallet_address);
        
        ;; Update owner -> wallets mapping
        storage::owner_wallets = add_to_index(storage::owner_wallets, wallet_owner_address, wallet_address);
        
        ;; Update receiver -> wallets mapping
        storage::receiver_wallets = add_to_index(storage::receiver_wallets, receiver_address, wallet_address);
        
        ;; Update auto claim list if needed
        if (is_auto_claim) {
            (int wallet_wc, int wallet_hash) = parse_std_addr(wallet_address);
            storage::auto_claim_wallets~udict_set_builder(267, wallet_hash, begin_cell().store_int(-1, 1));
        }
        
        ;; Save updated data
        save_data();
        return ();
    }
    
    if (op == op::update_recipient) {
        ;; Update recipient for an existing wallet
        slice wallet_address = in_msg_body~load_msg_addr();
        slice old_receiver = in_msg_body~load_msg_addr();
        slice new_receiver = in_msg_body~load_msg_addr();
        
        ;; Remove wallet from old receiver's list
        (int old_wc, int old_hash) = parse_std_addr(old_receiver);
        (slice old_list_slice, int old_found) = storage::receiver_wallets.udict_get?(267, old_hash);
        
        if (old_found) {
            cell old_dict = old_list_slice.preload_ref();
            (int wallet_wc, int wallet_hash) = parse_std_addr(wallet_address);
            
            ;; Remove wallet from old receiver's list
            (_, int was_found) = old_dict.udict_delete?(267, wallet_hash);
            
            ;; Update receiver wallets
            storage::receiver_wallets~udict_set_ref(267, old_hash, old_dict);
        }
        
        ;; Add wallet to new receiver's list
        storage::receiver_wallets = add_to_index(storage::receiver_wallets, new_receiver, wallet_address);
        
        ;; Save updated data
        save_data();
        return ();
    }
    
    if (op == op::log_claim) {
        ;; Log a claim event (optional, can be extended with more details)
        slice wallet_address = in_msg_body~load_msg_addr();
        int claimed_amount = in_msg_body~load_coins();
        
        ;; Here we could store claim history if needed
        ;; For now, just accept the log message
        return ();
    }
    
    if (op == op::log_cancel) {
        ;; Log a contract cancellation
        slice wallet_address = in_msg_body~load_msg_addr();
        
        ;; Here we could implement logic to remove the wallet from all indexes,
        ;; or mark it as canceled. For simplicity, we'll keep it in the logs
        ;; but could be extended as needed.
        return ();
    }
}

;; Get methods

;; Get all wallets for a token
cell get_token_wallets(slice token_address) method_id {
    load_data();
    
    if (~ storage::init?) {
        return new_dict();
    }
    
    (int wc, int addr_hash) = parse_std_addr(token_address);
    (slice token_list_slice, int token_found) = storage::token_wallets.udict_get?(267, addr_hash);
    
    if (~ token_found) {
        return new_dict();
    }
    
    return token_list_slice.preload_ref();
}

;; Get all wallets for an owner
cell get_owner_wallets(slice owner_address) method_id {
    load_data();
    
    if (~ storage::init?) {
        return new_dict();
    }
    
    (int wc, int addr_hash) = parse_std_addr(owner_address);
    (slice owner_list_slice, int owner_found) = storage::owner_wallets.udict_get?(267, addr_hash);
    
    if (~ owner_found) {
        return new_dict();
    }
    
    return owner_list_slice.preload_ref();
}

;; Get all wallets for a receiver
cell get_receiver_wallets(slice receiver_address) method_id {
    load_data();
    
    if (~ storage::init?) {
        return new_dict();
    }
    
    (int wc, int addr_hash) = parse_std_addr(receiver_address);
    (slice receiver_list_slice, int receiver_found) = storage::receiver_wallets.udict_get?(267, addr_hash);
    
    if (~ receiver_found) {
        return new_dict();
    }
    
    return receiver_list_slice.preload_ref();
}

;; Get all wallets with auto claim enabled
cell get_auto_claim_wallets() method_id {
    load_data();
    
    if (~ storage::init?) {
        return new_dict();
    }
    
    return storage::auto_claim_wallets;
}

;; Get logger owner
slice get_owner() method_id {
    load_data();
    return storage::owner;
}