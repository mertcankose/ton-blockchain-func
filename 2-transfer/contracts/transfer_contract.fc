#include "imports/stdlib.fc";

;; Operation codes
const int op::increment = 1;
const int op::withdraw = 2;
const int op::change_owner = 3;

;; Error codes
const int error::insufficient_fee = 101;
const int error::not_authorized = 102;

;; Fee amount (0.01 TON = 10000000000)
const int INCREMENT_FEE = 10000000000;

int equal_slice_bits(slice a, slice b) asm "SDEQ";

;; Storage format
;; strict value:(## 64) owner_address:MsgAddressInt = Storage;

(int, slice) load_data() inline {
    slice ds = get_data().begin_parse();
    if (ds.slice_empty?()) {  ;; İlk deploy için kontrol
        return (0, null());   ;; Varsayılan değerler
    }
    return (
        ds~load_uint(64),      ;; value
        ds~load_msg_addr()     ;; owner_address
    );
}

() save_data(int value, slice owner_address) impure inline {
    set_data(
        begin_cell()
            .store_uint(value, 64)
            .store_slice(owner_address)
        .end_cell()
    );
}

() check_owner(slice sender_address, slice owner_address) impure inline {
    throw_unless(error::not_authorized, equal_slice_bits(sender_address, owner_address));
}

;; İç mesajları işle
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Parse sender address
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    
    ;; Bounce check
    if (flags & 1) { return (); }

    ;; Empty message handling - Initial deployment
    if (in_msg_body.slice_empty?()) {
        save_data(0, sender_address);
        return ();
    }

    ;; Load contract data
    (int value, slice owner_address) = load_data();
    
    ;; Parse op
    int op = in_msg_body~load_uint(4);
    
    ;; Increment operation - anyone can do
    if (op == op::increment) {
        int inc_value = in_msg_body~load_uint(64);
        int old_value = value;  ;; eski değeri sakla
        value += inc_value;

        ~dump(op);           ;; operation code
        ~dump(inc_value);    ;; artış miktarı
        ~dump(old_value);    ;; eski değer
        ~dump(value);        ;; yeni değer

        save_data(value, owner_address);
        return ();
    }

    ;; Withdraw operation - only owner
    if (op == op::withdraw) {
        ;; Owner check
        check_owner(sender_address, owner_address);
        
        ;; Reserve minimum balance
        raw_reserve(10000000, 0);
        
        ;; Send remaining balance
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0, 32)
            .end_cell();
            
        send_raw_message(msg, 128 + 16);
        return ();
    }

    ;; Change owner operation - only owner
    if (op == op::change_owner) {
        check_owner(sender_address, owner_address);
        slice new_owner = in_msg_body~load_msg_addr();
        save_data(value, new_owner);
        return ();
    }

    ;; If no operation matched
    throw(0xffff);
}

;; Getter methods
(int, slice) get_contract_data() method_id {
    (int value, slice owner) = load_data();
    return (value, owner);
}

int get_value() method_id {
    (int value, _) = load_data();
    return value;
}

slice get_owner() method_id {
    (_, slice owner) = load_data();
    return owner;
}